#!/usr/bin/python3 -W ignore::DeprecationWarning
# -*- coding:utf8 -*-
import sys
import spacy
import re
import codecs
from document_parser import DocumentParser

# using medium sized Spacy model
nlp = spacy.load("en_core_web_md")


def load_text(filename):
    with open(filename) as textFile:
        text = textFile.read()
        parser = DocumentParser(text)
        return parser


def who(question, sentence):
    #only correct for non-compound sentences (two subject+verb pairings)
    #when compound sentence -> handle each part as different sentence
    #check if PERSON in each one, if yes then compare sentence with question and choose correct sentence
    """
    question_words = question.split()[1:]
    sentence_comma_split = sentence.split(",")
    sentence_words = []
    for s in sentence_comma_split:
        sentence_words.append(s.split())
    """
    ans = ""
    people = []
    has_person = False

    #check if there's a PERSON in the sentence
    for ent in sentence.entities:
        if ent.type == "PERSON":
            people.append(ent.text)
            has_person = True
    if not has_person:
        return ans

    subject = ""
    for elem in sentence.dependencies:
        if elem[1][:5] == "nsubj" and elem[0].deprel == "root":
            subject = elem[2].text
            break

    for person in people:
        if person == subject:
            return person

    return people[0]


def what(question, sentence):
    ans = ""
    return ans


def when(question, sentence):
    ans = ""
    return ans


def get_first_NNS(words):
    for word in words:
        if word.xpos == 'NNS':
            return word


def howmany(question, sentence):
    how_many_noun = get_first_NNS(question.words)
    CD_NNS_ans = ''
    for word in sentence.words:
        if word.xpos == 'CD':
            if len(sentence.words) >= word.id:
                CD_adj_word = get_first_NNS(sentence.words[word.id:])
                if CD_adj_word.xpos == 'NNS':
                    if CD_adj_word.text.lower() == how_many_noun.text.lower():
                        CD_NNS_ans = word.text + ' ' + CD_adj_word.text

    return CD_NNS_ans


def where(question, sentence):

    ans = ""
    return ans


def why(question, sentence):
    ans = ''

    def find_because_index(sentence):
        for word in sentence.words:
            if word.text.lower() == 'because':
                return word.id - 1
        return None
    because_i = find_because_index(sentence)
    if because_i == None:
        return ''
    else:
        for word in sentence.words[because_i:len(sentence.words) - 1]:
            if word.text == ',':
                ans += word.text
            else:
                ans = ans + word.text + ' '
    return ans.capitalize()


def yesno(question, sentence):
    return sentence.text

# return empty string if no answer


def answer(question, article):
    ans = ""
    max_sim = 0
    max_sim_sentence = None
    q = nlp(question.text)
    for sentence in article:
        s = nlp(sentence.text)
        sim = q.similarity(s)
        if sim > max_sim:
            max_sim = sim
            max_sim_sentence = sentence

    first_two = question.words[:2]
    first_word_lemma = first_two[0].lemma
    if first_two[0].text == "Who":
        ans = who(question, max_sim_sentence)
    elif first_two[0].text == "What":
        ans = what(question, max_sim_sentence)
    elif first_two[0].text == "When":
        ans = when(question, max_sim_sentence)
    elif first_two[0].text == "Where":
        ans = where(question, max_sim_sentence)
    elif first_two[0].text == "Why":
        ans = why(question, max_sim_sentence)
    elif first_two[0].text == "How" and first_two[1].text == "many":
        ans = howmany(question, max_sim_sentence)
    elif first_word_lemma == "do" or first_word_lemma == "be":
        ans = yesno(question, max_sim_sentence)

    return ans


if __name__ == "__main__":
    input_file = sys.argv[1]
    question_file = sys.argv[2]
    article = load_text(input_file)
    questions = load_text(question_file)
    answers = []

    # empty string/blank line if not able to answer question
    for q in questions.sentences:
        ans = answer(q, article.sentences)
        answers.append(ans)

    for a in answers:
        print(a)

    """
    with open(question_file, 'r') as f:
        count = 0
        for line in f:
            count += 1
            print('A'+str(count))
    """
