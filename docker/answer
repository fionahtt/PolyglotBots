#!/usr/bin/python3 -W ignore::DeprecationWarning
# -*- coding:utf8 -*-
import sys
import spacy
import re
import codecs
from document_parser import DocumentParser

# using medium sized Spacy model
nlp = spacy.load("en_core_web_md")


def load_text(filename):
    with open(filename) as textFile:
        text = textFile.read()
        parser = DocumentParser(text)
        return parser


def who(question, sentence):
    #only correct for non-compound sentences (two subject+verb pairings)
    #when compound sentence -> handle each part as different sentence
    #check if PERSON in each one, if yes then compare sentence with question and choose correct sentence
    """
    question_words = question.split()[1:]
    sentence_comma_split = sentence.split(",")
    sentence_words = []
    for s in sentence_comma_split:
        sentence_words.append(s.split())
    """
    ans = ""
    people = []
    has_person = False

    #check if there's a PERSON in the sentence
    for ent in sentence.entities:
        if ent.type == "PERSON":
            if ent.text not in question.text:
                people.append(ent.text)
                has_person = True
    if not has_person:
        return ans

    if len(people) == 1:
        return people[0]

    ans = people[0]

    subject = ""
    for elem in sentence.dependencies:
        if elem[1][:5] == "nsubj" and elem[0].deprel == "root":
            subject = elem[2].text
            break

    for person in people:
        if person == subject:
            ans = person

    return ans

def isValidwhatSentence(sentence):
    if len(sentence.constituency.children[0].children) < 3:
        return False

    possible_np = sentence.constituency.children[0].children[0].label
    possible_vp = sentence.constituency.children[0].children[1].label
    #possible_period = sentence.constituency.children[0].children[2].label

    if possible_np != "NP" or possible_vp != "VP":  # or possible_period != ".":
        return False

    return True

def get_children(pt):
    phrase = ""
    for elem in pt:
        if elem.children == ():
            first = elem.label[0]
            if elem.label == ",":
                phrase += elem.label
            elif first == "'" or first == "-":
                phrase += elem.label
            else:
                phrase += " " + elem.label
        else:
            phrase += get_children(elem.children)
    return phrase


def getVerbPhrase(sentence):
    vp = sentence.constituency.children[0].children[1].children
    verb_phrase = get_children(vp)
    return verb_phrase


def getNounPhrase(sentence):
    vp = sentence.constituency.children[0].children[0].children
    verb_phrase = get_children(vp)
    return verb_phrase

def what(question, sentence):

    if not (isValidwhatSentence(sentence)):
        return None

    main_question_part = (getVerbPhrase(question))
    np = (getNounPhrase(sentence)).strip()
    vp = (getVerbPhrase(sentence)).strip()

    pq = nlp(main_question_part)
    pnp = nlp(np)
    pvp = nlp(vp)

    sim1 = pq.similarity(pnp)
    sim2 = pq.similarity(pvp)

    if (sim1 > sim2):
        return get_children(sentence.constituency.children[0].children[1].children[1].children).strip()
    else:
        return np


def when(question, sentence):
    #handle composite sentences (only want to look in part of sentence with most matching words)
    ans = ""
    times = []
    has_time = False

    for ent in sentence.entities:
        if ent.type == "DATE" or ent.type == "TIME" or ent.type == "EVENT":
            if ent.text not in question.text:
                times.append(ent.text)
                has_time = True
    if not has_time:
        return ans

    ans = times[0]

    return ans


def get_first_NNS(words):
    for word in words:
        if word.xpos == 'NNS':
            return word


def howmany(question, sentence):
    how_many_noun = get_first_NNS(question.words)
    CD_NNS_ans = ''
    for word in sentence.words:
        if word.xpos == 'CD':
            if len(sentence.words) >= word.id:
                CD_adj_word = get_first_NNS(sentence.words[word.id:])
                if CD_adj_word.xpos == 'NNS':
                    if CD_adj_word.text.lower() == how_many_noun.text.lower():
                        CD_NNS_ans = word.text + ' ' + CD_adj_word.text

    return CD_NNS_ans


def where(question, sentence):
    #handle composite sentences (only want to look in part of sentence with most matching words)
    ans = ""
    locations = []
    has_location = False

    for ent in sentence.entities:
        if ent.type == "GPE" or ent.type == "LOC" or ent.type == "EVENT" or ent.type == "FAC":
            if ent.text not in question.text:
                locations.append(ent.text)
                has_location = True
    if not has_location:
        return ans

    ans = locations[0]

    return ans


def why(question, sentence):
    ans = ''

    def find_because_index(sentence):
        for word in sentence.words:
            if word.text.lower() == 'because':
                return word.id - 1
        return None
    because_i = find_because_index(sentence)
    if because_i == None:
        return ''
    else:
        for word in sentence.words[because_i:len(sentence.words) - 1]:
            if word.text == ',':
                ans += word.text
            else:
                ans = ans + word.text + ' '
    return ans.capitalize()


def yesno(question, sentence):
    return sentence.text

# return empty string if no answer



def answer(question, article):
    ans = ""
    q = nlp(question.text)
    sentences = []
    sentence_scores = []
    for sentence in article:
        s = nlp(sentence.text)
        sim = q.similarity(s)
        while sim in sentence_scores:
            sim += 0.0000000000000001
        sentence_scores.append(sim)
        sentences.append(sentence)
    max_3 = sorted(zip(sentence_scores, sentences), reverse=True)[:30]

    def get_ans(question, function):
        index = 0
        ans = None
        while((ans == None or ans == "") and index < 3):
            matched_sentence = max_3[index][1]
            try:
                ans = function(question,matched_sentence)
            except:
                ans = None
            index +=1
        return ans

    first_two = question.words[:2]
    first_word_lemma = first_two[0].lemma
    if first_two[0].text == "Who" or first_two[0].text == "Whom" :
        ans = get_ans(question, who)
    elif first_two[0].text == "What":
        ans = get_ans(question, what)
    elif first_two[0].text == "When":
        ans = get_ans(question, when)
    elif first_two[0].text == "Where":
        ans = get_ans(question, where)
    elif first_two[0].text == "Why":
        ans = get_ans(question, why)
    elif first_two[0].text == "How" and first_two[1].text == "many":
        ans = get_ans(question, howmany)
    elif first_word_lemma == "do" or first_word_lemma == "be":
        ans = get_ans(question, yesno)

    return ans


if __name__ == "__main__":
    input_file = sys.argv[1]
    question_file = sys.argv[2]
    article = load_text(input_file)
    questions = load_text(question_file)
    answers = []

    # empty string/blank line if not able to answer question
    for q in questions.sentences:
        ans = answer(q, article.sentences)
        answers.append(ans)

    for a in answers:
        if (a == None):
            print("")
        else:
            print(a)

    """
    with open(question_file, 'r') as f:
        count = 0
        for line in f:
            count += 1
            print('A'+str(count))
    """
