#!/usr/bin/python3 -W ignore::DeprecationWarning
# -*- coding:utf8 -*-

from io import DEFAULT_BUFFER_SIZE
import sys
import codecs
import stanza
from document_parser import DocumentParser


def load_text(filename):
    with open(filename) as textFile:
        text = textFile.read()
        parser = DocumentParser(text)
        return parser

# if possible return question, if not return None


def is_simple_predicate(sentence):
    tree = sentence.constituency
    # Check to make sure node is a sentence
    if(tree.children[0].label != 'S'):
        return False
    tree_labels = tree.children[0].children
    correct_labels = ['NP', 'VP', '.']
    # check to make sure sentence node only has 3 children
    if (len(tree_labels) != 3):
        return False
    for i in range(3):
        if tree_labels[i].label != correct_labels[i]:
            return False
    return True


"""
small grammar error with get_children:
-sometimes "3-0" becomes "3- 0"
"""


def get_children(pt):
    phrase = ""
    for elem in pt:
        if elem.children == ():
            first = elem.label[0]
            if elem.label == ",":
                phrase += elem.label
            elif first == "'" or first == "-":
                phrase += elem.label
            else:
                phrase += " " + elem.label
        else:
            phrase += get_children(elem.children)
    return phrase


def get_len_children(pt):
    pt_len = 0
    for elem in pt:
        if elem.children == ():
            first = elem.label[0]
            if elem.label == ",":
                pt_len += 1
            elif first == "'" or first == "-":
                pt_len += 1
            else:
                pt_len += 1
        else:
            pt_len += get_len_children(elem.children)
    return pt_len

def checkValidWhatSentence(sentence):
    # WE not Rockin with people
    for ent in sentence.entities:
        if ent.type == "PERSON":
            return False

    if len(sentence.constituency.children[0].children) < 3:
        return False

    possible_np = sentence.constituency.children[0].children[0].label
    possible_vp = sentence.constituency.children[0].children[1].label
    #possible_period = sentence.constituency.children[0].children[2].label

    if possible_np != "NP" or possible_vp != "VP":  # or possible_period != ".":
        return False

    return True


def getVerbPhrase(sentence):
    vp = sentence.constituency.children[0].children[1].children
    verb_phrase = get_children(vp)
    return verb_phrase


def getNounPhrase(sentence):
    vp = sentence.constituency.children[0].children[0].children
    verb_phrase = get_children(vp)
    return verb_phrase


def handleIfSentence(sentence):
    return None


def checkNPPP(phrase):
    return (len(phrase) == 2 and phrase[0].label == "NP" and phrase[1].label == "PP")


def getIsEndPhrase(np, vp):
    if checkNPPP(np):
        return get_children(np).strip()
    elif checkNPPP(vp[1].children):
        # Remove the word is
        return get_children(vp).strip()[3:]
    return None

# seth


def what(sentence):
    try:
        question_head = "What"

        if not checkValidWhatSentence(sentence):
            return None

        constParse = sentence.constituency.children[0]
        mainVerb = constParse.children[1].children[0].children[0].label

        if mainVerb == 'is':
            # Check if we should use the Noun Phrase or Verb Phrase for this question
            endPhrase = getIsEndPhrase(
                sentence.constituency.children[0].children[0].children, sentence.constituency.children[0].children[1].children)
            if (endPhrase == None):
                return None
            else:
                endPhrase = endPhrase[0].lower() + endPhrase[1:]
            return f"What is {endPhrase}?"

        return None
    except IndexError as e:
        return None
        pass

# fiona
"""
NER may not work for some names of people,
but ultimately works better than other processors 
that only can point out proper nouns
(for "who" we want a person)
Only want a proper noun person for a "good" question 
(can't answer with "her" for a question)
Only takes in sentences with proper noun in [NP]
________________
Verb [VP] formats:
verb_tenses
verb_tenses + [something] ([VP], [NP], etc)
________________
Limitations:
Does not ask questions about sentences with person in verb phrase
- "The best person is Lauren" 
NER may not recognize name of person as name, or may classify something that is not a name
as a name
Grammar limitations: "The Johnsons like to swim" -> "Who like to swim?"
Supposed to be "Who likes to swim?" (present tense supposed to have singular verb form)
____________
Sentence formats: simple predicate ([NP] + [VP])
Question format: Who + singular form of [VP] (past and present)
-done by taking all children of [VP] and making sure it's in singular form
Covers verb + infinitive (want to ___, likes to ___)
Covers modal verbs (would ___, could ___, could have ___) -> [MD] + [VP]
"""

def who(sentence):
    question = "Who"
    has_person = False

    # check if sentence has a proper noun person
    # get first person mentioned in sentence (will be in [NP])
    for ent in sentence.entities:
        if ent.type == "PERSON":
            has_person = True
            break
    if not has_person:
        return None

    verb_tenses = ["VBZ", "VBD", "VBP", "MD"]

    # check sentence format (w/o period)
    if len(sentence.constituency.children[0].children) < 3:
        return None

    possible_np = sentence.constituency.children[0].children[0].label
    possible_vp = sentence.constituency.children[0].children[1].label
    #possible_period = sentence.constituency.children[0].children[2].label

    if possible_np != "NP" or possible_vp != "VP":  # or possible_period != ".":
        return None

    # check verb formats of [VP]
    vp = sentence.constituency.children[0].children[1].children
    if vp[0].label not in verb_tenses:
        return None

    """
    # check that proper noun person is in noun phrase
    np = sentence.constituency.children[0].children[0].children
    noun_phrase = get_children(np)
    if person not in noun_phrase:
        return None
    """

    # get entire [VP]
    verb_phrase = get_children(vp)

    # make first verb
    first_verb = verb_phrase.split()[0]

    return question + verb_phrase + "?"


"""
check that there's a proper noun in a phrase
used to check whether there's proper noun in NP (good question)
Limitations: returns true if there's any NNP in the phrase
when checking for NNP in [NP] it doesn't always work
"He, as the president of the USA, went to the beach."
-> True because "USA" is considered NNP but would be bad question b/c don't know who "he" is
(issue for all question templates, including who)
"""

# List[ParseTree] -> bool


def check_NNP(pt):
    for elem in pt:
        if elem.children[0].children == ():
            if elem.label == "NNP":
                return True
    return False

# check that [PP] has a DATE


def check_pp_has_date(pp_phrase, dates):
    pp_has_date = False
    for d in dates:
        if d in pp_phrase:
            pp_has_date = True
    return pp_has_date


def get_lemma(sentence, vp):
    # get index of first verb in sentence to get in Word form
    first_verb = vp[0].children[0].label
    sentence_text = []

    # doing this instead of sentence.text.split() because need to capture puntuaction
    # as separate words
    for w in sentence.words:
        sentence_text.append(w.text)
    first_verb_ind = sentence_text.index(first_verb)
    first_verb_word = sentence.words[first_verb_ind]

    # get lemma of first verb
    first_verb_lemma = first_verb_word.lemma

    return first_verb_lemma


def construct_question(np, vp, switch_order, do_tense, first_verb_lemma):
    first_verb = vp[0].children[0].label
    np_phrase = get_children(np)
    vp_phrase = get_children(vp)
    vp_split = vp_phrase.split(' ', 2)
    if len(vp_split) < 3:
        wo_first_verb = ""
    else:
        wo_first_verb = " " + vp_split[2]

    if switch_order:
        return " " + first_verb + np_phrase + wo_first_verb + "?"

    return do_tense + np_phrase + " " + first_verb_lemma + wo_first_verb + "?"


"""
Sentence format:
Form 1: [PP] with DATE + [NP] + [VP]
Form 2: [NP] + [VP] with [PP] with DATE
_________
Question format:
When did/does/do [NP] + [VP] (w/o [PP] with DATE if Form 2) (lemma form of verb)
-VBD => did
-VBP => do
-VBZ => does
_________
We only consider dates within a [PP] because:
-something like "60 years" is classified as date -> could be age
_________
Limitations:
Limited to sentences with format above
For a sentence with both forms, the question will ask about the date in the first [PP]
"""

# fiona


def when(sentence):
    question = "When"
    has_date = False
    dates = []  # keep track of dates in sentence to check if [PP] has one
    # check if sentence has a date entity
    for ent in sentence.entities:
        if ent.type == "DATE":
            has_date = True
            dates.append(ent.text)
    if not has_date:
        return None

    # verb tense of [VP] matching to do/does/did
    tense_matching = {"VBD": " did", "VBP": " do", "VBZ": " does"}
    verb_tenses = ["VBD", "VBP", "VBZ"]

    # check sentence format
    if len(sentence.constituency.children[0].children) < 3:
        return None

    np_or_pp = sentence.constituency.children[0].children[0].label

    if np_or_pp != "PP":
        if np_or_pp != "NP":
            return None
        else:
            # [NP] + [VP] + [.] form (w/o period)
            possible_vp = sentence.constituency.children[0].children[1].label
            possible_period = sentence.constituency.children[0].children[2].label
            if possible_vp != "VP" or possible_period != ".":
                return None
    else:
        # [PP] + [,] + [NP] + [VP] + [.] form (w/o period)
        possible_comma = sentence.constituency.children[0].children[1].label
        possible_np = sentence.constituency.children[0].children[2].label
        possible_vp = sentence.constituency.children[0].children[3].label
        if possible_comma != "," or possible_np != "NP" or possible_vp != "VP":
            return None

    #[PP] + [NP] + [VP]

    if np_or_pp == "PP":
        pp = sentence.constituency.children[0].children[0].children
        np = sentence.constituency.children[0].children[2].children
        vp = sentence.constituency.children[0].children[3].children

        # check proper noun (NNP) in noun phrase
        if not check_NNP(np):
            return None

        # check DATE in [PP]
        pp_phrase = get_children(pp)
        pp_has_date = check_pp_has_date(pp_phrase, dates)
        if pp_has_date == False:
            return None

        # get tense of do
        vp_tense = vp[0].label
        do_tense = ""
        switch_order = False  # if [MD] or be/have + participle ([VBN/VBG])
        if vp_tense == "MD":
            switch_order = True
        elif vp_tense not in verb_tenses:
            return None
        else:
            do_tense = tense_matching[vp_tense]

        lemma = get_lemma(sentence, vp)
        if (lemma == "be" or lemma == "have"):
            switch_order = True

        rest_of_question = construct_question(
            np, vp, switch_order, do_tense, lemma)

        return question + rest_of_question

    # [NP][VP] (with [PP] in last part of [VP])
    # doesn't work with verb + infinitive
    else:
        np = sentence.constituency.children[0].children[0].children
        vp = sentence.constituency.children[0].children[1].children

        # get tense of do
        vp_tense = vp[0].label
        do_tense = ""
        switch_order = False  # if [MD] or be/have + participle ([VBN/VBG])
        if vp_tense == "MD":
            switch_order = True
        elif vp_tense not in verb_tenses:
            return None
        else:
            do_tense = tense_matching[vp_tense]

        lemma = get_lemma(sentence, vp)
        if (lemma == "be" or lemma == "have"):
            switch_order = True

        # check last part of [VP] is [PP] (with date)
        if switch_order:
            if vp[1].label != "VP":
                return None
            if vp[1].children[-1].label != "PP":
                return None
            pp = vp[1].children[-1].children
            vp = [vp[0]] + vp[1].children[:-1]
        else:
            if vp[-1].label != "PP":
                return None
            pp = vp[-1].children
            vp = vp[:-1]

        # check DATE in [PP]
        pp_phrase = get_children(pp)
        pp_has_date = check_pp_has_date(pp_phrase, dates)
        if pp_has_date == False:
            return None

        rest_of_question = construct_question(
            np, vp, switch_order, do_tense, lemma)

        return question + rest_of_question

    return None

# fiona


def where(sentence):
    return None

# look for "because": Because...[NP][VP] or [NP][VP w because]


def why(sentence):
    return None

# rahjshiba


def howmany(sentence):

    if not is_simple_predicate(sentence):
        return None
    question = "How many "

    tree = sentence.constituency
    NP_node = tree.children[0].children[0]
    VP_node = tree.children[0].children[1]
    root_verb_index = get_len_children(NP_node.children)

    subject = sentence.words[0:root_verb_index]
    predicate = sentence.words[root_verb_index:]

    (sub_nummod_i, pred_nummod_i) = is_howmany(subject, predicate)

    if (sub_nummod_i, pred_nummod_i) == (None, None):
        return None
    elif pred_nummod_i == None:
        phrase_start = sentence.words[sub_nummod_i].head - 1
        for word in sentence.words[phrase_start:len(sentence.words) - 1]:
            question = question + word.text.lower() + ' '
    elif sub_nummod_i == None:
        phrase_start = sentence.words[pred_nummod_i].head - 1
        how_many_noun = sentence.words[phrase_start]
        question = question + how_many_noun.text + " "
        (expl_does_question_result, is_aux) = expl_does_question_phrase(
            subject, predicate, sentence.words[root_verb_index])

        question = question + expl_does_question_result + " "

        del predicate[len(subject) - pred_nummod_i - 1]
        del predicate[len(subject) - pred_nummod_i]
        for word in predicate[1:len(predicate) - 1]:
            if word == ',':
                question = question + ","
            question = question + word.text.lower() + " "
    question += '?'
    return question


def auxilary_verb_flip(subject, verb):
    aux_verbs = ['be', 'have', 'can', 'could', 'will', 'would', 'do']
    aux_verb = None
    flipped_aux_phrase = ''
    if len(subject) > 0 and verb.lemma in aux_verbs:
        aux_verb = verb
        flipped_aux_phrase = flipped_aux_phrase + aux_verb.text + ' '
        start_word = (subject[0].text) if (
            subject[0].xpos == 'NNP' or subject[0].xpos == 'NNPS') else (subject[0].text.lower())
        flipped_aux_phrase = flipped_aux_phrase + start_word + ' '
        for word in subject[1:len(subject)]:
            if word == ',':
                flipped_aux_phrase = flipped_aux_phrase + ","
            flipped_aux_phrase = flipped_aux_phrase + word.text + ' '
        return flipped_aux_phrase
    return None


def expl_does_question_phrase(subject, predicate, verb):
    has_expl = None
    conjugated_do = ''
    flipped_verb_phrase = ''

    aux_verb_flipped_phrase = auxilary_verb_flip(subject, verb)

    for word in subject:
        if word.deprel == 'expl':
            has_expl = word
            break

    for word in subject:
        if word.xpos == 'PRP':
            if word.text.lower() in ['it', 'he', 'she']:
                conjugated_do = 'does '
                break
            elif word.text.lower() in ['i', 'you', 'we', 'they']:
                conjugated_do = 'do'
                break
        elif word.xpos == 'NNP':
            conjugated_do = 'does '
            break
        elif word.xpos == 'NNS':
            conjugated_do = 'do '
            break
        elif word.xpos == 'NN':
            conjugated_do = 'does '
            break

    if has_expl != None:
        flipped_verb_phrase = verb.text + has_expl.text + " "
    elif aux_verb_flipped_phrase != None:
        flipped_verb_phrase = aux_verb_flipped_phrase
    else:
        flipped_verb_phrase = conjugated_do + " "
        start_word = (subject[0].text) if (
            subject[0].xpos == 'NNP' or subject[0].xpos == 'NNPS') else (subject[0].text.lower())
        flipped_verb_phrase = flipped_verb_phrase + start_word + ' '
        for word in subject[1:]:
            if word == ',':
                flipped_aux_phrase = flipped_aux_phrase + ","
            flipped_verb_phrase = flipped_verb_phrase + word.text + " "

        flipped_verb_phrase += verb.lemma
    return (flipped_verb_phrase, aux_verb_flipped_phrase != None)


def is_howmany(subject, predicate):
    (sub_i, pred_i) = (None, None)
    for word in subject:
        if word.deprel == 'nummod':
            sub_i = word.id - 1
    for word in predicate:
        if word.deprel == 'nummod':
            pred_i = word.id - 1
    return (sub_i, pred_i)


# rahjshiba
def yesno(sentence):
    if not is_simple_predicate(sentence):
        return None

    tree = sentence.constituency
    NP_node = tree.children[0].children[0]
    VP_node = tree.children[0].children[1]
    root_verb_index = get_len_children(NP_node.children)

    subject = sentence.words[0:root_verb_index]
    predicate = sentence.words[root_verb_index:]
    verb = sentence.words[root_verb_index]

    (expl_does_question_result, is_aux) = expl_does_question_phrase(
        subject, predicate, sentence.words[root_verb_index])

    expl_does_question_result_split = expl_does_question_result.split()

    yes_no_question = expl_does_question_result_split[0].capitalize(
    ) + ' ' + " ".join(expl_does_question_result_split[1:]) + ' '

    for word in predicate[1:len(predicate) - 1]:
        if word == ',':
            yes_no_question = yes_no_question + ","
        yes_no_question = yes_no_question + word.text + ' '

    yes_no_question += '?'

    return yes_no_question


if __name__ == "__main__":
    input_file = sys.argv[1]
    N = int(sys.argv[2])
    parser = load_text(input_file)
    # get parser.sentences with appositions
    questions = []

    for sentence in parser.sentences:
        print("This is the sentence: " + sentence.text)
        who_question = who(sentence)
        what_question = what(sentence)
        howmany_question = howmany(sentence)
        yesno_question = yesno(sentence)
        when_question = when(sentence)

        if (who_question != None):
            questions.append(who_question)
        if (howmany_question != None):
            questions.append(howmany_question)
        if (what_question != None):
            questions.append(what_question)
        if (yesno_question != None):
            questions.append(yesno_question)
        if (when_question != None):
            questions.append(when_question)

    for i in range(N):
        if (i < len(questions)):
            print(questions[i])
        else:
            print("Question Limit Exceeded")
