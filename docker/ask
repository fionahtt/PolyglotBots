#!/usr/bin/python3 -W ignore::DeprecationWarning
# -*- coding:utf8 -*-

from io import DEFAULT_BUFFER_SIZE
import sys
import codecs
import stanza
from document_parser import DocumentParser

def load_text(filename):
    with open(filename) as textFile:
        text = textFile.read()
        parser = DocumentParser(text)
        return parser

# if possible return question, if not return None

"""
NER may not work for some names of people,
but ultimately works better than other processors 
that only can point out proper nouns
(for "who" we want a person)

Only want a proper noun person for a "good" question 
(can't answer with "her" for a question)

Only takes in sentences with proper noun in [NP]

________________

Verb [VP] formats:

verb_tenses
verb_tenses + [something] ([VP], [NP], etc)

________________

Sentence formats: simple predicate ([NP] + [VP])

Some limitations: "The best person is Lauren" -> "Who is Lauren?"
But not "Who is the best person?"

Grammar limitations: "The Johnsons like to swim" -> "Who like to swim?"
Supposed to be "Who likes to swim?" (present tense supposed to have singular verb form)
____________

Question format: Who + singular form of [VP] (past and present)
-done by taking all children of [VP] and making sure it's in singular form

Covers verb + infinitive (want to ___, likes to ___)
Covers modal verbs (would ___, could ___, could have ___) -> [MD] + [VP]
"""

"""
small grammar error with get_children:
-sometimes "3-0" becomes "3- 0"
"""

def get_children(pt):
    phrase = ""
    for elem in pt:
        if elem.children == ():
            first = elem.label[0]
            if elem.label == ",":
                phrase += elem.label
            elif first == "'" or first == "-":
                phrase += elem.label
            else:
                phrase += " " + elem.label
        else:
            phrase += get_children(elem.children)
    return phrase



#fiona
def who(sentence):
    question = "Who"
    has_person = False
    person = ""

    #check if sentence has a proper noun person
    #get first person mentioned in sentence (will be in [NP])
    for ent in sentence.entities:
        if ent.type == "PERSON":
            has_person = True
            person = ent.text
            break
    if not has_person:
        return None

    verb_tenses = ["VBZ", "VBD", "VBP", "MD"]

    # check sentence format (w/o period)
    if len(sentence.constituency.children[0].children) < 3:
        return None

    possible_np = sentence.constituency.children[0].children[0].label
    possible_vp = sentence.constituency.children[0].children[1].label
    #possible_period = sentence.constituency.children[0].children[2].label

    if possible_np != "NP" or possible_vp != "VP": #or possible_period != ".":
        return None

    #check verb formats of [VP]
    vp = sentence.constituency.children[0].children[1].children
    if vp[0].label not in verb_tenses:
        return None

    #check that proper noun person is in noun phrase
    np = sentence.constituency.children[0].children[0].children
    noun_phrase = get_children(np)
    if person not in noun_phrase:
        return None

    #get entire [VP]
    verb_phrase = get_children(vp)

    #make first verb 
    first_verb = verb_phrase.split()[0]
    
    return question + verb_phrase + "?"

# seth
def what(sentence):
    return

"""
Sentence format:

Form 1: [PP] with DATE + [NP] + [VP]
Form 2: [NP] + [VP] with [PP] with DATE

_________
Question format:

When did/does/do [NP] + [VP] (w/o [PP] with DATE if Form 2) (lemma form of verb)
-VBD => did
-VBP => do
-VBZ => does
_________

We only consider dates within a [PP] because:
-something like "60 years" is classified as date -> could be age
_________

Limitations:
Limited to sentences with format above
For a sentence with both forms, the question will ask about the date in the first [PP]
Cannot process sentence with modal verb [MD] form, or be/have + participle ([VBN/VBG])
-On Monday, he should go to work => When should he go to work?
 currently: "When did/does/do he should go to work?"
-On Monday, he had gone to work => When had he gone to work?
 currently: "When did/does/do he had gone to work?"

"""

"""
TO DO:
[PP] in [VP] format
"""

"""
check that there's a proper noun in a phrase
used to check whether there's proper noun in NP (good question)

Limitations: returns true if there's any NNP in the phrase
when checking for NNP in [NP] it doesn't always work
"He, as the president of the USA, went to the beach."
-> True because "USA" is considered NNP but would be bad question b/c don't know who "he" is
"""

# List[ParseTree] -> bool
def check_NNP(pt):
    for elem in pt:
        if elem.children[0].children == ():
            if elem.label == "NNP":
                return True
    return False

# fiona
def when(sentence):
    question = "When"
    has_date = False
    dates = [] #keep track of dates in sentence to check if [PP] has one
    #check if sentence has a date entity
    for ent in sentence.entities:
        if ent.type == "DATE":
            has_date = True
            dates.append(ent.text)
    if not has_date:
        return None

    #verb tense of [VP] matching to do/does/did
    tense_matching  = {"VBD": " did", "VBP": " do", "VBZ": " does"}
    verb_tenses = ["VBD", "VBP", "VBZ"]

    # check sentence format 
    if len(sentence.constituency.children[0].children) < 3:
        return None

    np_or_pp = sentence.constituency.children[0].children[0].label
    pp_first = False

    if np_or_pp != "PP":
        if np_or_pp != "NP":
            return None
        else:
            # [NP] + [VP] + [.] form (w/o period)
            possible_vp = sentence.constituency.children[0].children[1].label
            #possible_period = sentence.constituency.children[0].children[2].label
            if possible_vp != "VP": # or possible_period != ".":
                return None
    else:
        # [PP] + [,] + [NP] + [VP] + [.] form (w/o period)
        possible_comma = sentence.constituency.children[0].children[1].label
        possible_np = sentence.constituency.children[0].children[2].label
        possible_vp = sentence.constituency.children[0].children[3].label
        if possible_comma != "," or possible_np != "NP" or possible_vp != "VP":
            return None
    
    #[PP] + [NP] + [VP]

    if np_or_pp == "PP":
        pp = sentence.constituency.children[0].children[0].children
        np = sentence.constituency.children[0].children[2].children
        vp = sentence.constituency.children[0].children[3].children

        #check proper noun (NNP) in noun phrase
        if not check_NNP(np):
            return None

        #check DATE in [PP]
        pp_phrase = get_children(pp)
        pp_has_date = False
        for d in dates:
            if d in pp_phrase:
                pp_has_date = True
        if pp_has_date == False:
            return None

        # get tense of do
        vp_tense = vp[0].label
        switch_order = False # if [MD] or be/have + participle ([VBN/VBG])
        if vp_tense not in verb_tenses:
            return None
        elif vp_tense == "MD":
            switch_order = True
        else:
            do_tense = tense_matching[vp_tense]

         # get index of first verb in sentence to get in Word form
        first_verb = vp[0].children[0].label
        sentence_text = []
        # doing this instead of sentence.text.split() because need to capture puntuaction
        # as separate words
        for w in sentence.words:
            sentence_text.append(w.text)
        first_verb_ind = sentence_text.index(first_verb)
        first_verb_word = sentence.words[first_verb_ind]

        # get lemma of first verb
        first_verb_lemma = first_verb_word.lemma
        if (first_verb_lemma == "be" or first_verb_lemma == "have"):
            switch_order = True

        np_phrase = get_children(np)
        vp_phrase = get_children(vp)
        wo_first_verb = " " + vp_phrase.split(' ', 2)[2]

        if switch_order:
            return question + " " + first_verb + np_phrase + wo_first_verb + "?"
        else:
            return question + do_tense + np_phrase + " " + first_verb_lemma + wo_first_verb + "?"

    #check DATE in [PP] in [VP]
    #else:


    return None

# rahjshiba
def howmany(sentence):
    question = "How many"
    nsubj_head = 0
    for word in sentence.words:
        if word.head == 0:
            nsubj_head = word.id - 1
            break

    subject = sentence.words[0:nsubj_head]
    predicate = sentence.words[nsubj_head:]

    (sub_nummod_i, pred_nummod_i) = is_howmany(subject, predicate)

    if (sub_nummod_i, pred_nummod_i) == (None, None):
        return None
    elif pred_nummod_i == None:
        phrase_start = sentence.words[sub_nummod_i].head - 1
        for word in sentence.words[phrase_start:len(sentence.words) - 1]:
            question = question + " " + word.text.lower()
    elif sub_nummod_i == None:
        phrase_start = sentence.words[pred_nummod_i].head - 1
        how_many_noun = sentence.words[phrase_start]
        question = question + " " + how_many_noun.text
        question = question + " " + \
            expl_does_question_phrase(
                subject, predicate, sentence.words[nsubj_head])
        for word in sentence.words[phrase_start + 1: len(sentence.words) - 1]:
            question = question + " " + word.text.lower()
    question += '?'
    return question


def auxilary_verb_flip(subject, verb):
    aux_verbs = ['be', 'have', 'can', 'could', 'will', 'would', 'do']
    aux_verb = None
    flipped_aux_phrase = ''
    if subject[len(subject) - 1].lemma in aux_verbs:
        aux_verb = subject[len(subject) - 1]
        flipped_aux_phrase = flipped_aux_phrase + aux_verb.text.lower() + ' '
        for word in subject[0:len(subject) - 1]:
            flipped_aux_phrase = flipped_aux_phrase + word.text.lower() + ' '
            flipped_aux_phrase = flipped_aux_phrase + verb.text.lower() + ' '
        return flipped_aux_phrase
    return None


def expl_does_question_phrase(subject, predicate, verb):
    has_expl = None
    conjugated_do = None
    flipped_verb_phrase = ''
    aux_verb_flipped_phrase = auxilary_verb_flip(subject, verb)

    for word in subject:
        if word.deprel == 'expl':
            has_expl = word
            break

    for word in subject:
        if word.xpos == 'PRP':
            if word.text.lower() in ['it', 'he', 'she']:
                conjugated_do = 'does'
                break
            elif word.text.lower() in ['i', 'you', 'we', 'they']:
                conjugated_do = 'do'
                break
        elif word.xpos == 'NNP':
            conjugated_do = 'does'
            break
        elif word.xpos == 'NNS':
            conjugated_do = 'do'
            break
        elif word.xpos == 'NN':
            conjugated_do = 'does'
            break

    if has_expl != None:
        flipped_verb_phrase = verb.text.lower() + " " + has_expl.text.lower()
    elif aux_verb_flipped_phrase != None:
        flipped_verb_phrase = aux_verb_flipped_phrase
    else:
        flipped_verb_phrase = conjugated_do + " "
        for word in subject:
            flipped_verb_phrase = flipped_verb_phrase + word.text.lower() + " "

        flipped_verb_phrase += verb.lemma
    return flipped_verb_phrase


def is_howmany(subject, predicate):
    (sub_i, pred_i) = (None, None)
    for word in subject:
        if word.deprel == 'nummod':
            sub_i = word.id - 1
    for word in predicate:
        if word.deprel == 'nummod':
            pred_i = word.id - 1
    return (sub_i, pred_i)


# rahjshiba
def yesno(sentence):
    nsubj_head = 0
    for word in sentence.words:
        if word.head == 0:
            nsubj_head = word.id - 1
            break
    subject = sentence.words[0:nsubj_head]
    predicate = sentence.words[nsubj_head:]
    verb = sentence.words[nsubj_head]

    yes_no_question = expl_does_question_phrase(subject, predicate, verb) + ' '

    for word in predicate[1:len(predicate) - 1]:
        yes_no_question = yes_no_question + word.text.lower() + ' '
    
    yes_no_question += '?'

    return yes_no_question.capitalize()

if __name__ == "__main__":
    input_file = sys.argv[1]
    N = int(sys.argv[2])
    parser = load_text(input_file)
    questions = []

    for sentence in parser.sentences:
        #print(sentence.text)
        #print(sentence.constituency)

        #who_question = who(sentence)
        #howmany_question = howmany(sentence)
        when_question = when(sentence)
        """
        if (who_question != None):
            questions.append(who_question)
        if (howmany_question != None):
            questions.append(howmany_question)
        """

        if (when_question != None):
            questions.append(when_question)

    for i in range(N):
        if (i < len(questions)):
            print(questions[i])

# load_text("text/pie.txt")


# howmany1 = nlp('Five dogs walk.')
# howmany2 = nlp('He has five kids at the house.')
# howmany3 = nlp('There are 7 apples.')
# howmany4 = nlp('The tall trees laying in the sun have 6 apples.')
# howmany5 = nlp('it remains one of the 88 modern constellations today.')
# howmany6 = nlp('They have 3 cats.')
# howmany7 = nlp('Harriet is walking 3 dogs.')
# howmany8 = nlp('You swim 6 miles.')
# howmany9 = nlp('The tall trees which they were climbing had 6 apples.')
# howmany10 = nlp('The tall tree covered in spiders had 6 apples.')


# print(howmany(howmany1.sentences[0]))
# print(howmany(howmany2.sentences[0]))
# print(howmany(howmany3.sentences[0]))
# print(howmany(howmany4.sentences[0]))
# print(howmany(howmany5.sentences[0]))
# print(howmany(howmany6.sentences[0]))
# print(howmany(howmany7.sentences[0]))
# print(howmany(howmany8.sentences[0]))
# print(howmany(howmany9.sentences[0]))
# print(howmany(howmany10.sentences[0]))
# print(yesno(howmany1.sentences[0]))
# print(yesno(howmany2.sentences[0]))
# print(yesno(howmany3.sentences[0]))
# print(yesno(howmany4.sentences[0]))
# print(yesno(howmany5.sentences[0]))
# print(yesno(howmany6.sentences[0]))
# print(yesno(howmany7.sentences[0]))
# print(yesno(howmany8.sentences[0]))
# print(yesno(howmany9.sentences[0]))
# print(yesno(howmany10.sentences[0]))

